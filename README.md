# README

### Alex, Jared, Joseph

## Why this project?

We started this problem aiming to solve a problem familiar to gaming-inclined people everywhere: when looking for friends to play games with online, how do you know what they are playing and on what platform? There are ways to do this in each of the game platform silos - Steam on PC, Xbox Live, PSN for Playstation - but these do not speak with each other in a way that would allow one to see what friends are playing across the board.

This is where our app comes into play: when you log in, all of your friends on the social platform show up on your personalized main page, indicating their gaming status, the platform being used, and how many people are in their party at that moment. We also allowed for the creation of events in the future and in-person, for those so inclined, which allows for better planning for pastimes like Magic the Gathering or Dungeons and Dragons.  

## Project Methodologies
#### Group Project
The most serious challenge we faced during this project was not as much the technical hurdles as it was the issues that crop up when three people are working on one set of code. We solved this in a fairly expected way: solid planning. Early on, we recognized that having more than one controller (in this case, for User, Event, and Game objects) as well as similarly-themed database accessor objects and associated entities. This allowed us to work on separate sections as the back-end was being built up and tested and then, once we had the basic structure set, further allowed for a division of labor between the front and back-ends, minimizing merge conflicts to a total of two minor overlaps over the course of the entire project.

#### Agile Work Environment
Greatly helping our group dynamic was our implementation of a more agile work environment. The more workplace-oriented practice of having two week sprints was quite untenable for a week-long project, so we modified these practices to have both morning and afternoon stand-up meetings in place of a traditional sprint. This allowed us to keep close tabs on where the project stood, where any issues were cropping up, and whether or not we needed to sit down for some pair programming to figure out an intractable problem. Using these practices, we were able to not only avoid code conflicts but the conflicts that arise when communication has broken down and team members find themselves at loggerheads.

#### Pair Programming
At last, pair programming. Your friendly readme writer happens to be a huge proponent of this practice, as it tends to solidify techniques and information that may have been glossed over previously. As a group, we found that talking out problems with each other solved 

## Technologies

### CRUD
### JPA
### SQL
### JAVAAAA
### Spring Framework
### HTML/CSS
### AWS

more to come.


### Issues Seen, Issues Solved
#### Mapped Relationships
#### Modals
#### Password Hashing
#### HTML/CSS
#### Session Management
#### GIT Issues
#### Spring MVC
#### DAOs
#### Admin vs. Regular User
